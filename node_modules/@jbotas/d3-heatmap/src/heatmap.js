import {
    select,
    selectAll,
    scaleSequential,
    interpolateBuPu,
    max,
    scaleBand,
    axisBottom,
    axisLeft,
} from 'd3';

class Heatmap {
    constructor(selector, data,
        vars={ x:'x', y:'y', value:'value' },
        getters={ getX:undefined, getY:undefined },
        width=0, height=0) {
        this.container = select(selector)
        this.svg;
        this.data;
        this.dataX;
        this.dataY;
        this.x = vars.x;
        this.y = vars.y;
        this.val = vars.value;
        this.updateData(data, false);
        this.margin = {
                top: 50,
                right: 10,
                bottom: 10,
                left: 10,
        }
        this.rect = {
            width: 20,
            r: 0,
        }
        this.color = {
            background: 'white',
            text: 'black',
            highlight: 'orange',
        }
        this.duration = 500;
        this.delay = {
            enter: 2*this.duration,
            update: this.duration,
            exit: 0,
        }
        this.width = width;
        this.height = height;
        this.computeDimensions();
        // Build color palette
        this.palette;
        this.buildPalette();
        // Build reusable tooltip
        this.tooltip;
        this.buildTooltip();
        // Draw svg
        this.buildCanvas()
        // Build axis scales
        this.xAxis, this.yAxis;
        this.buildAxis();
        // Optional y coordinate function getter
        this.getX = getters.getX || (d => this.xAxis(d[this.x]));
        this.getY = getters.getY || (d => this.yAxis(d[this.y]));
        // Draw heatmap
        this.draw()
    }

    computeDimensions() {
        let width = Math.max(this.width, this.rect.width * this.dataX.length)
        let height = Math.max(this.height, this.rect.width * this.dataY.length)
        this.width = width;
        this.height = height;
    }

    capitalize(string) {
        return string.trim().replace(/^\w/, c => c.toUpperCase());
    }

    buildPalette() {
      // Build color scale
      this.palette = scaleSequential()
        .interpolator(interpolateBuPu)
        .domain([0, max(this.data, d => d[this.val])])
    }

    buildAxis() {
        this.container
            .select('.xAxis')
            .style('opacity', 0)
            .remove()
        this.container
            .select('.yAxis')
            .style('opacity', 0)
            .remove()
        // Build X scales and axis:
        this.xAxis = scaleBand()
            .range([0, this.width])
            .domain(this.dataX)
            .padding(0.05);
        let xAxis = this.svg
            .append('g')
            .attr('class', 'xAxis')
            .style('font-size', 15)
            .attr('transform', `translate(0, -12)`)
        xAxis
            .call(axisBottom(this.xAxis).tickSize(0))
            .select('.domain').remove()
        xAxis
            .style('opacity', 0)
            .transition()
            .duration(this.duration)
            .delay(this.delay.enter)
            .style('opacity', 1)
        // Build Y scales and axis:
        this.yAxis = scaleBand()
            .range([this.height, 0])
            .domain(this.dataY)
            .padding(0.05);
        let yAxis = this.svg.append('g')
            .attr('class', 'yAxis')
            .style('font-size', 15)
        yAxis
            .call(axisLeft(this.yAxis).tickSize(0))
            .select('.domain').remove()
        yAxis
            .style('opacity', 0)
            .transition()
            .duration(this.duration)
            .delay(this.delay.enter)
            .style('opacity', 1)
        // Add ids to ticks
        this.container
            .selectAll('.xAxis .tick')
            .attr('id', d => `x_${d}`)
            .style('transition', 'color .3s')
            .select('text')
            .attr('transform', 'rotate(-45)')
            .attr('dx', -4)
            .attr('dy', 0)

        this.container
            .selectAll('.yAxis .tick')
            .attr('id', d => `y_${d}`)
            .style('transition', 'color .3s')
    }

    buildCanvas() {
        this.svg = this.container
            .append('svg')
            .attr('class', '.heatmapSVG')
              .attr('width', this.width
                + this.margin.left
                + this.margin.right)
              .attr('height', this.height
                + this.margin.top
                + this.margin.bottom)
            .append('g')
              .attr('transform',
                      `translate(${this.margin.left},
                                 ${this.margin.top})`);
        // Hide tooltip when outside of container
        this.container.on('mouseleave', () => this.mouseclick(false))
    }

    buildTooltip() {
        // create a tooltip
        this.tooltip = this.container
            .append('div')
            .style('opacity', 0)
            .attr('class', 'tooltip')
            .style('position', 'absolute')
            .style('font-size', '11px')
            .style('background-color', this.color.background)
            .style('border', 'solid')
            .style('border-width', '1px')
            .style('border-radius', '5px')
            .style('padding', '5px')
            .style('transition', 'opacity .5s');
        this.tooltip
            .append('div')
            .attr('class', 'tooltip-arrow')
    }

    // Heatmap squares' event listeners
    mouseover(e, d) {
        select(e.target)
          .style('stroke', this.color.text)
          .style('opacity', 1);
        [`#x_${d[this.x]}`, `#y_${d[this.y]}`].forEach(id => {
            this.container
                .select(id)
                .style('color', this.color.highlight)
        });
    }

    mousemove(e, d) {
        let coordinates = e.target.getBoundingClientRect();
        this.tooltip
          .html(`${this.capitalize(this.x)}: ${d[this.x]}<br>`
              + `${this.capitalize(this.y)}: ${d[this.y]}<br>`
              + `${this.capitalize(this.val)}: ${d[this.val]}`)
          .transition()
          .duration(50)
          .style('left', (coordinates.left + this.rect.width*.9) + 'px')
          .style('top', (coordinates.top + this.rect.width*.9) + 'px')
    }

    mouseleave(e, d) {
        select(e.target)
          .style('stroke', 'none')
          .style('opacity', .6);
        [`#x_${d[this.x]}`, `#y_${d[this.y]}`].forEach(id => {
            this.container
                .select(id)
                .style('color', this.color.text)
        });
    }

    mouseclick(toggle=true) {
        let opacity;
        opacity = toggle
            ? +!+this.tooltip.style('opacity')
            : 0;
        // Toggle tooltip
        this.tooltip
          .style('opacity', opacity);
    }

    draw() {
      // add the squares
      let squares = this.svg.selectAll('rect.heatRect')
        .data(this.data, d => d[this.x]+':'+d[this.y]);
      let squareEnter = squares
        .enter()
        .append('rect')
            .attr('class', 'heatRect')
            .attr('rx', this.rect.r)
            .attr('ry', this.rect.r)
            .style('stroke-width', 1.5)
            .style('stroke', 'transparent')
            .style('opacity', 0)
            .style('transition', ' stroke .3s, opacity .3s')
            .style('cursor', 'pointer');
        squareEnter
            .on('mouseover', (e, d) => this.mouseover(e, d))
            .on('mousemove', (e, d) => this.mousemove(e, d))
            .on('mouseleave', (e, d) => this.mouseleave(e, d))
            .on('click', e => this.mouseclick(e))
        let squareUpdate = squareEnter
            .merge(squares)
            .transition()
            .duration(this.duration)
            .delay(this.delay.update)
            .attr('x', d => this.getX(d))
            .attr('y', d => this.getY(d))
            .attr('width', this.xAxis.bandwidth())
            .attr('height', this.yAxis.bandwidth())
            .style('fill', d => this.palette(d[this.val]))
            .style('opacity', .6)
        squares.exit()
            .transition()
            .duration(this.duration)
            .delay(this.delay.exit)
            .style('opacity', 0)
            .remove()
    }

    update() {
        this.computeDimensions();
        this.buildPalette();
        this.buildAxis();
        this.draw();
    }

    updateData(data, update=true) {
        this.data = data;
        this.dataX =  [...new Set(this.data.map(d => d[this.x]))]
        this.dataY = [...new Set(this.data.map(d => d[this.y]))]
        if(update) this.update();
    }

    updateX(x) {
        this.x = x;
        this.updateData(this.data);
    }

    updateY(y) {
        this.y = y;
        this.updateData(this.data);
    }

    hideX() {
        this.container.select('.xAxis').remove()
    }

    hideY() {
        this.container.select('.yAxis').remove()
    }

    updateVal(val) {
        this.val = val;
        this.updateData(this.data);
    }
}

export default Heatmap;
