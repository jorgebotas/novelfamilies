"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

require("core-js/stable");

require("regenerator-runtime/runtime");

var _d2 = require("d3");

var _jquery = _interopRequireDefault(require("jquery"));

var _fileSaver = require("file-saver");

var _html2canvas = _interopRequireDefault(require("html2canvas"));

var _d3Heatmap = _interopRequireDefault(require("@jbotas/d3-heatmap"));

var _customBar = _interopRequireDefault(require("./customBar"));

var _helpers = require("./helpers");

var _newick = _interopRequireDefault(require("./newick"));

var _palette = _interopRequireDefault(require("./palette"));

var _popper = require("./popper");

var _tree = _interopRequireDefault(require("./tree"));

var _sorter = _interopRequireDefault(require("./sorter.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var GeCoViz = function GeCoViz(selector) {
  var unfData = [];
  var data = [];
  var newick;
  var newickFields;
  var anchors = [];
  var swappedAnchors = [];
  var nSide = 2;
  var width = 700;
  var height = 700;
  var margin = {
    top: 10,
    left: 10
  };
  var showName = "";
  var notation = "";
  var notationLevel;
  var excludedNotation = [];
  var excludedAnchors = [];
  var URLs = {
    kegg: {
      b: 'https://www.kegg.jp/dbget-bin/www_bget?map',
      a: ''
    },
    unigene: {
      b: 'http://gmgc.embl.de/search.cgi?search_id=GMGC10.',
      a: '.UNKNOWN&search_seq='
    },
    eggnog: {
      b: 'http://eggnog5.embl.de/#/app/results?target_nogs=',
      a: ''
    },
    pfam: {
      b: 'https://pfam.xfam.org/family/',
      a: ''
    },
    //taxonomy : {
    //b : 'https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?mode=Info&id=',
    //a : '&&lvl=3&lin=f&keep=1&srchmode=1&unlock'
    //}
    taxonomy: {
      b: 'https://gtdb.ecogenomic.org/searches?s=al&q=',
      a: ''
    }
  };
  var duration = 500;
  var delay = {
    enter: duration * 2,
    update: duration,
    exit: 0
  };
  var geneRect = {
    w: width / (2 * nSide + 1),
    h: 17,
    ph: 20,
    pv: 5
  };
  var tipWidth = 2 * geneRect.ph / 5;
  var domain = [];
  var palette = new _palette["default"]();
  var customBar;
  var enterGenes, updateGenes, exitGenes;
  var updateShowName, updateNotation, updateLegend, updateWidth, updateHeight;
  var treeLeafEnter, treeLeafExit, treeLeafMouseOver, treeLeafMouseLeave, treeLeafClick;
  var options = {
    showName: true,
    showTree: true,
    showLegend: true,
    scaleDist: false
  }; // Color variables

  var color = {
    primary: 'var(--indigo)',
    noData: 'var(--nodata)',
    highlight: 'var(--highlight)',
    black: 'var(--black)',
    white: 'var(--white)',
    darkGray: 'var(--dark-gray)',
    sand: 'var(--sand)',
    darkPurple: 'var(--dark-purple)',
    purple: 'var(--purple)'
  };
  var leafColor = {
    stroke: color.purple,
    fill: color.sand
  };

  function chart(selection) {
    selection.each(function () {
      function getX(d) {
        if (options.scaleDist) return +d.vStart;else return (+d.pos + nSide) * geneRect.w;
      }

      function getY(d) {
        var y;

        try {
          y = (0, _d2.select)(selector + ' #leaf' + (0, _helpers.cleanString)(d.anchor)).node().__data__.x;
          return y - 11;
        } catch (_unused) {}

        return anchors.findIndex(function (a) {
          return a.anchor == d.anchor;
        }) * geneRect.h;
      }

      function getShowName(d) {
        var geneName = d[showName];

        if (["", "NA", undefined].every(function (i) {
          return i != geneName;
        })) {
          var size = +Math.floor(d.geneWidth / 13.5);
          var name = d[showName];

          if (size < name.length) {
            name = name.slice(0, size);
          }

          geneName = name;
        } else {
          geneName = ".";
        }

        return geneName;
      }

      updateShowName = function updateShowName() {
        (0, _d2.selectAll)('text.geneName').transition().duration(duration).style('opacity', 0).transition().duration(duration).style('opacity', function (g) {
          return options.showName && getShowName(g) != "." ? 1 : 0;
        }).text(function (g) {
          return getShowName(g);
        });
      };

      treeLeafEnter = function treeLeafEnter(l) {
        chart.excludeAnchor(l.data.name, false);
      };

      treeLeafExit = function treeLeafExit(l) {
        chart.excludeAnchor(l.data.name, true);
      };

      treeLeafMouseOver = function treeLeafMouseOver(_, l) {
        var anchor = (0, _helpers.cleanString)(l.data.name);
        var genes = graphContainer.selectAll("[id^=\"gene".concat(anchor, "\"]"));
        genes.select('.stroke').style('opacity', 1);
      };

      treeLeafMouseLeave = function treeLeafMouseLeave(_, l) {
        var anchor = (0, _helpers.cleanString)(l.data.name);
        var genes = graphContainer.selectAll("[id^=\"gene".concat(anchor, "\"]"));
        genes.select('.stroke').style('opacity', 0);
      };

      treeLeafClick = function treeLeafClick(event, l) {
        if (event.altKey) {
          var name = l.data.name;
          var excluded = excludedAnchors.includes(name);
          chart.excludeAnchor(l.data.name, !excluded);
        }
      };

      function initChart(container) {
        customBar = new _customBar["default"](selector, data);
        customBar.drawBar();
        customBar.updateLevels(notation);
        graphContainer = container.append('div').attr('class', 'graph-container');
        graphContainer.append('div').attr('class', 'phylogramContainer p-1');
        contextAndLegend = graphContainer.append('div').attr('class', 'gcontextAndLegend').style('opacity', 0);
        contextContainer = contextAndLegend.append('div').attr('class', 'gcontext m-1');
        contextAndLegend.transition().duration(duration).delay(delay.enter * 1.5).style('opacity', 1);
        legendContainer = contextAndLegend.append('div').attr('class', 'p-1 pt-0 legendContainer').append('div').attr('class', 'legend w-100 h-100');
        drawLegend();
        var contextSVG = contextContainer.insert('svg', '.legendContainer').attr('class', 'gcontextSVG').attr('width', width).attr('height', height);
        contextG = contextSVG.append('g').attr('transform', "translate(".concat(margin.left, ", ").concat(margin.top, ")"));
        chart.toggleTree(true);
        updateWidth();
        contextSVG.attr('width', width);
        contextG.selectAll('g.gene').data(data, function (d) {
          return d.anchor + d.pos;
        }).enter().append('g').attr('class', function (d) {
          var cl = 'gene';
          cl += d.pos == 0 ? ' anchor' : '';
          return cl;
        }).attr('id', function (d) {
          return 'gene' + (0, _helpers.cleanString)(d.anchor + d.pos);
        }).attr('transform', function (d) {
          return "translate(".concat(getX(d), ", ").concat(getY(d), ")");
        }).transition().duration(duration).delay(delay.enter).style('opacity', 1).each(enterGene);
      }

      function getArrow(d, x0, rectWidth, tipWidth) {
        var tipPath, strokePath;
        var rect = geneRect;

        if (d.strand == "-") {
          tipPath = ["M", x0, " ", "0", " ", "L", x0 - tipWidth, " ", (rect.h - rect.pv) / 2, " ", "L", x0, " ", rect.h - rect.pv, " ", "Z"].join("");
          strokePath = ["M", x0, " ", "0", " ", "L", x0 - tipWidth, " ", (rect.h - rect.pv) / 2, " ", "L", x0, " ", rect.h - rect.pv, " ", "L", x0 + rectWidth - rect.ph, " ", rect.h - rect.pv, " ", "L", x0 + rectWidth - rect.ph, " ", "0", " ", "Z"].join("");
        } else {
          tipPath = ["M", x0 + rectWidth - rect.ph, " ", "0", " ", "L", x0 + rectWidth - rect.ph + tipWidth, " ", (rect.h - rect.pv) / 2, " ", "L", x0 + rectWidth - rect.ph, " ", rect.h - rect.pv, " ", "Z"].join("");
          strokePath = ["M", x0 + rectWidth - rect.ph, " ", "0", " ", "L", x0 + rectWidth - rect.ph + tipWidth, " ", (rect.h - rect.pv) / 2, " ", "L", x0 + rectWidth - rect.ph, " ", rect.h - rect.pv, " ", "L", x0, " ", rect.h - rect.pv, " ", "L", x0, " ", "0", "Z"].join("");
        }

        return {
          tipPath: tipPath,
          strokePath: strokePath
        };
      }

      function filterByLevel(d) {
        return !notationLevel ? true : !d.level ? true : d.level == notationLevel;
      }

      function filterNotation(n) {
        return excludedNotation.includes(n.id) ? false : filterByLevel(n);
      }

      function scoreNotation() {
        var nots = data.map(function (d) {
          return !d[notation] ? [] : _typeof(d[notation]) == 'object' ? d[notation].filter(filterByLevel) : [{
            id: d[notation]
          }];
        }).flat();
        var count = (0, _helpers.counter)(nots, 'id');
        var total = Object.values(count).reduce(function (total, d) {
          return total + d;
        }, 0);
        var uniqueNotation = {};
        nots.forEach(function (n) {
          return uniqueNotation[n.id] = n;
        });
        uniqueNotation = _toConsumableArray(Object.values(uniqueNotation));
        uniqueNotation.forEach(function (n) {
          n.score = +(count[n.id] / total).toFixed(3);
        });
        uniqueNotation.sort(function (a, b) {
          return b.score - a.score;
        });
        return uniqueNotation;
      }

      updateNotation = function updateNotation() {
        contextG.selectAll('g.gene').each(updateGene);
      };

      updateLegend = function updateLegend() {
        // Update title
        splitLegend.select('.legend-title').style('opacity', 0).html(notation.toUpperCase()).transition().duration(duration).style('opacity', 1);
        var uniqueNotation = scoreNotation();
        var factor = 60; // Scale legend to fit all data

        var legendHeight = uniqueNotation.length * factor;
        splitLegend.transition().duration(duration).delay(delay.update).style("height", Math.min(window.innerHeight - 50, legendHeight + 100) + "px");
        var legendEntry = splitLegend.selectAll('.lgnd-entry').data(uniqueNotation);
        var legendEntryEnter = legendEntry.enter().append('div').attr('class', 'lgnd-entry').style("outline", "none").style("display", "flex");
        legendEntryEnter.on('mouseover', function (_, n) {
          return graphContainer.selectAll("path.stroke.c".concat((0, _helpers.cleanString)(n.id))).style('opacity', 1);
        });
        legendEntryEnter.on('mouseleave', function (_, n) {
          return graphContainer.selectAll("path.stroke.c".concat((0, _helpers.cleanString)(n.id))).style('opacity', 0);
        });
        legendEntryEnter.append('svg').attr("width", 40).attr("height", 40).style("display", "inline-block").style("margin-top", "6px").append("circle").attr("r", 6).attr("cx", 20).attr("cy", 6.5).style("fill", function (n) {
          return palette.get(n.id);
        });
        var checkboxDivEnter = legendEntryEnter.append("div").style("display", "inline-block").style("outline", "none");
        var checkboxLabelEnter = checkboxDivEnter.append('label').attr('class', 'form-check m-1 ml-2');
        checkboxLabelEnter.append('input').attr("type", "checkbox").attr("checked", "").attr("style", "margin-top:0 !important;").on('change', function (e, n) {
          e.target.checked ? chart.excludeNotation(n.id, false) : chart.excludeNotation(n.id, true);
        });
        checkboxLabelEnter.append('span').attr("class", "form-check-label");
        checkboxDivEnter.append("div").attr("class", "w-100 lgnd-entry-description").style("display", "block").style("max-height", "45px").style("height", "45px");
        var legendEntryMerged = legendEntryEnter.merge(legendEntry).attr('class', function (n) {
          return 'lgnd-entry ' + "lgnd".concat((0, _helpers.cleanString)(n.id));
        });
        legendEntryMerged.select('circle').transition().duration(duration).style("fill", function (n) {
          return palette.get(n.id);
        });
        legendEntryMerged.select('input').attr('class', function (n) {
          return 'mt-0 form-check-input rounded-pill ' + "form-check-legend lgnd-switch lgnd".concat((0, _helpers.cleanString)(n.id));
        });
        legendEntryMerged.select('span').html(function (n) {
          return !URLs[notation] ? "<em>".concat(n.id, "</em>") : '<a href="' + URLs[notation].b + String(n.id) + URLs[notation].a + '" target="_blank" style="outline:none;">' + String(n.id) + '</a>';
        });
        legendEntryMerged.select('.lgnd-entry-description').html(function (n) {
          return "<strong class='font-weight-bold'>                        conservation: ".concat(n.score, "                        </strong><br>") + (n.description || '');
        });
        legendEntry.exit().style('opacity', 0).remove();
        splitLegend.selectAll('div').style('opacity', 0).transition().duration(duration).delay(delay.enter).style('opacity', 1);
      };

      function drawLegend() {
        // Sticky legend
        var stickyLegend = legendContainer.append('div').attr('class', 'sticky-legend sticky'); // Legend is split to optimize space

        splitLegend = stickyLegend.append('div').attr('class', 'split-legend notation-legend mt-1').style('width', '300px'); // Legend title

        splitLegend.append('div').attr('class', 'legend-title font-weight-bold'); // Select-all checkbox

        (0, _helpers.addCheckbox)(splitLegend.append("div").attr("class", "pl-3").style("display", "flex"), "Select all", "form-check-legend lgnd-toggleAll"); // No data legend entry

        var noData = splitLegend.append("div").style("outline", "none").style("display", "flex");
        var noDataSVG = noData.append("svg").attr("width", 40).attr("height", 40).style("display", "inline-block");
        noDataSVG.append('circle').attr("r", 6).attr("cx", 20).attr("cy", 6.5).style("fill", color.noData);
        noData.append("div").style("display", "inline-block").style("outline", "none").html("No data");
        updateLegend(splitLegend); // Toggle checkboxes if clicked

        var legendSwitch = splitLegend.select('.lgnd-toggleAll');
        legendSwitch.on('change', function () {
          var switches = splitLegend.selectAll('.lgnd-switch');
          legendSwitch.property('checked') ? switches.property('checked', true) : switches.property('checked', false);
          switches.nodes().forEach(function (s) {
            return (0, _helpers.triggerEvent)(s, 'change');
          });
        });
      }

      function hoverGene(d) {
        var geneD3 = contextG.select("#gene" + (0, _helpers.cleanString)(d.anchor + d.pos));
        var stroke = geneD3.select('path.stroke');
        var geneName = geneD3.select('text.geneName');
        var leaf = graphContainer.select('#leaf' + (0, _helpers.cleanString)(d.anchor));
        var leafCircle = leaf.select('circle');
        var leafText = leaf.select('text');

        function mouseOver() {
          stroke.style('opacity', 1);
          geneName.style('fill', color.black); // Highlight tree

          leafCircle.style('stroke', color.highlight).style('fill', color.highlight);
          leafText.style('fill', color.highlight);
          var nots = d[notation];
          if (_typeof(nots) != 'object') nots = [{
            id: nots
          }];
          nots.filter(filterByLevel).forEach(function (n) {
            // Highlight legend
            var div = graphContainer.select(".lgnd".concat((0, _helpers.cleanString)(n.id)));
            var t = div.select('a');
            t = t.nodes().length == 0 ? div.select('em') : t;
            t.style('color', color.highlight);
          });
        }

        function mouseLeave() {
          stroke.style('opacity', 0);
          geneName.style('fill', color.white); // Highlight tree

          leafCircle.style('stroke', leafColor.stroke).style('fill', leafColor.fill);
          leafText.style('fill', color.darkGray);
          var nots = d[notation];
          if (_typeof(nots) != 'object') nots = [{
            id: nots
          }];
          nots.filter(filterByLevel).forEach(function (n) {
            // Highlight legend
            var div = graphContainer.select(".lgnd".concat((0, _helpers.cleanString)(n.id)));
            var t = div.select('a');
            t = t.nodes().length == 0 ? div.select('em') : t;
            t.style('color', color.primary);
          });
        }

        return {
          mouseOver: mouseOver,
          mouseLeave: mouseLeave
        };
      }

      function formatNotation(n) {
        var unfNots = !n || n.length == 0 ? [{
          id: 'NA'
        }] : _typeof(n) == 'object' ? n : [{
          id: n
        }];
        var nots = unfNots.filter(filterNotation);
        nots = nots.length == 0 ? [{
          id: 'NA'
        }] : nots;
        return {
          unfNots: unfNots,
          nots: nots
        };
      }

      function parameterListener() {
        // nSide slider
        var nSideSlider = container.select('.nSideSlider').node().noUiSlider;
        nSideSlider.on('change', function () {
          chart.nSide(Math.round(nSideSlider.get()));
        }); // Tree toggler

        var treeToggler = container.select('input.toggleTree');
        treeToggler.on('change', function () {
          options.showTree = treeToggler.property('checked');
          options.showTree ? chart.toggleTree(true) : chart.toggleTree(false);
        }); // Legend toggler

        var legendToggler = container.select('input.toggleLegend');
        legendToggler.on('change', function () {
          options.showLegend = legendToggler.property('checked');
          options.showLegend ? chart.toggleLegend(true) : chart.toggleLegend(false);
        }); // Scale distance and gene width

        var scaleDist = container.select('input.scaleDist');
        scaleDist.on('change', function () {
          options.scaleDist = scaleDist.property('checked');
          options.scaleDist ? chart.scaleDist(true) : chart.scaleDist(false);
        }); // Show on gene

        var showSelect = container.select('select.showName');
        var showOptions = showSelect.node();
        showSelect.on('change', function () {
          var newShowName = showOptions.options[showOptions.selectedIndex].value;
          if (newShowName != '' && newShowName != showName) chart.showName(newShowName);
        }); // Notation level

        var notationLevelSelect = container.select('select.notationLevel');
        var notationLevelOptions = notationLevelSelect.node();
        notationLevelSelect.on('change', function () {
          var newNotationLevel = notationLevelOptions.options[notationLevelOptions.selectedIndex].value;
          chart.notation(notation, newNotationLevel);
        }); // Notation options

        var notationSelect = container.select('select.notation');
        var notationOptions = notationSelect.node();
        notationSelect.on('change', function () {
          var newNotation = notationOptions.options[notationOptions.selectedIndex].value;
          customBar.updateLevels(newNotation);
          var notationLevelOption = notationLevelOptions.options[notationLevelOptions.selectedIndex].value;
          chart.notation(newNotation, notationLevelOption);
        });
        container.select('.shuffleColors').on('click', function () {
          return chart.shuffleColors();
        });
        container.select('.downloadPng').on('click', function () {
          return chart.toPng();
        });
      }

      updateWidth = function updateWidth() {
        var totalWidth = +graphContainer.node().clientWidth;
        var treeWidth = 0;

        if (newick && options.showTree) {
          treeWidth = +graphContainer.select('.phylogram svg').attr('target-width');
        }

        treeWidth = Math.min(.4 * totalWidth, treeWidth);
        graphContainer.select('.gcontextAndLegend').style('width', "calc(100% - ".concat(treeWidth, "px)"));
        width = graphContainer.select('.gcontext').node().clientWidth;
        graphContainer.select('.gcontextSVG').attr('width', width);
        geneRect.w = (width - 7) / (2 * nSide + 1);
      };

      updateHeight = function updateHeight() {
        // Avoid errors when tree is not present
        var targetHeight;

        try {
          targetHeight = graphContainer.select('.phylogram svg').attr('target-height');
        } catch (_unused2) {
          targetHeight = (0, _d2.max)(graphContainer.selectAll('g.gene').nodes().map(function (n) {
            return n.getBoundingClientRect().top;
          })) - graphContainer.node().getBoundingClientRect().top + geneRect.h + 10;
        }

        graphContainer.select('.gcontextSVG').transition().duration(duration).delay(delay.update).attr('height', targetHeight);
      };

      function resizeSVG() {
        if (options.scaleDist) {
          var farLeft = (0, _d2.min)(data, function (d) {
            return +d.vStart;
          });
          var farRight = (0, _d2.max)(data, function (d) {
            return +d.vEnd;
          });
          var svgWidth = farRight - farLeft + 2 * margin.left;
          contextContainer.select('.gcontextSVG').attr('width', svgWidth);
          contextG.attr('transform', "translate(".concat(-farLeft + margin.left, ", ").concat(margin.top, ")"));
          container.select('.gene.anchor').node().scrollIntoView({
            behavior: 'smooth',
            block: 'nearest',
            inline: 'center'
          });
        } else contextG.attr('transform', "translate(".concat(margin.left, ", ").concat(margin.top, ")"));
      }

      function enterGene(d) {
        var geneG = (0, _d2.select)(this);

        var _formatNotation = formatNotation(d[notation]),
            unfNots = _formatNotation.unfNots,
            nots = _formatNotation.nots;

        var nRect = +nots.length > 0 ? +nots.length : 1;
        var geneWidth;
        if (options.scaleDist) geneWidth = d.vSize;else geneWidth = geneRect.w;
        d.geneWidth = geneWidth;
        var barWidth = (geneWidth - geneRect.ph) / nRect;
        var x0; //, xf;

        x0 = d.strand == "-" ? tipWidth : 0;
        var geneRects = geneG.selectAll('rect.gene-rect').data(nots, function (n) {
          return n.id;
        });
        geneRects.enter().append('rect').attr('class', 'gene-rect').attr('fill', function (n) {
          return n.id == 'NA' ? color.noData : palette.get(n.id);
        }).attr('x', function (_, i) {
          return x0 + i * barWidth;
        }).attr('y', 0).attr('width', barWidth).attr('height', geneRect.h - geneRect.pv);

        var _getArrow = getArrow(d, x0, geneWidth, tipWidth),
            tipPath = _getArrow.tipPath,
            strokePath = _getArrow.strokePath;

        geneG.selectAll('path.gene-tip').data(function (d) {
          return d.strand == '-' ? [nots[0]] : [nots[nots.length - 1]];
        }, function (n) {
          return n.id;
        }).enter().append('path').attr('d', tipPath).attr('class', 'gene-tip').attr('fill', function (n) {
          return n.id == 'NA' ? color.noData : palette.get(n.id);
        });
        geneG.append('path').attr('d', strokePath).attr('class', 'light-stroke');
        geneG.append('path').attr('d', strokePath).attr('class', 'stroke ' + unfNots.filter(filterByLevel).map(function (n) {
          return "c".concat((0, _helpers.cleanString)(n.id));
        }).join(' ')).style('opacity', 0);
        geneG.append('text').attr('class', 'geneName').attr('x', geneWidth / 2 - geneRect.ph / 2 + (d.strand == '-' ? tipWidth : 0)).attr('y', geneRect.h / 1.7).style('opacity', function (g) {
          return options.showName && getShowName(g) != "." ? 1 : 0;
        }).text(function (g) {
          return getShowName(g);
        }); // Hover rationale

        var _hoverGene = hoverGene(d),
            mouseOver = _hoverGene.mouseOver,
            mouseLeave = _hoverGene.mouseLeave;

        var popperShow = (0, _popper.PopperCreate)(selector + ' .gcontext', d, URLs); // Gene SVG group

        geneG.node().childNodes.forEach(function (c) {
          c.addEventListener('click', popperShow);
          c.addEventListener('mouseover', mouseOver);
          c.addEventListener('mouseleave', mouseLeave);
        });
      }

      function updateGene(d) {
        var geneG = (0, _d2.select)(this);

        var _hoverGene2 = hoverGene(d),
            mouseOver = _hoverGene2.mouseOver,
            mouseLeave = _hoverGene2.mouseLeave;

        var popperShow = (0, _popper.PopperCreate)(selector + ' .gcontext', d, URLs);

        var _formatNotation2 = formatNotation(d[notation]),
            unfNots = _formatNotation2.unfNots,
            nots = _formatNotation2.nots;

        var nRect = +nots.length > 0 ? +nots.length : 1;
        var geneWidth;
        if (options.scaleDist) geneWidth = d.vSize;else geneWidth = geneRect.w;
        d.geneWidth = geneWidth;
        var barWidth = (geneWidth - geneRect.ph) / nRect;
        var x0; //, xf;

        x0 = d.strand == "-" ? tipWidth : 0;
        var geneRects = geneG.selectAll('rect.gene-rect').data(nots, function (n) {
          return n.id;
        });
        var geneRectsEnter = geneRects.enter().insert('rect', 'path').attr('class', 'gene-rect').attr('fill', function (n) {
          return n.id == 'NA' ? color.noData : palette.get(n.id);
        }).attr('x', function (_, i) {
          return x0 + i * barWidth;
        }).attr('y', 0).attr('width', 0).attr('height', geneRect.h - geneRect.pv).style('opacity', 0);
        geneRectsEnter.on('mouseover', function () {
          return mouseOver();
        }).on('mouseleave', function () {
          return mouseLeave();
        }).on('click', function () {
          return popperShow();
        }); // Updating gene rects

        var mergedGeneRects = geneRectsEnter.merge(geneRects);
        mergedGeneRects.transition().duration(duration).delay(delay.update).attr('x', function (_, i) {
          return x0 + i * barWidth;
        }).attr('width', barWidth);
        mergedGeneRects.transition().duration(duration).delay(delay.enter).attr('fill', function (n) {
          return n.id == 'NA' ? color.noData : palette.get(n.id);
        }).style('opacity', 1);
        geneRects.exit().transition().duration(duration).style('opacity', 0).remove();

        var _getArrow2 = getArrow(d, x0, geneWidth, tipWidth),
            tipPath = _getArrow2.tipPath,
            strokePath = _getArrow2.strokePath;

        var geneTip = geneG.selectAll('path.gene-tip').data(function (d) {
          return d.strand == '-' ? [nots[0]] : [nots[nots.length - 1]];
        }, function (n) {
          return n.id;
        });
        var geneTipEnter = geneTip.enter().insert('path', 'path.light-stroke').attr('class', 'gene-tip');
        geneTipEnter.attr('fill', function (n) {
          return n.id == 'NA' ? color.noData : palette.get(n.id);
        }).style('opacity', 0);
        var geneTipMerged = geneTipEnter.merge(geneTip);
        geneTipMerged.transition().duration(duration).delay(delay.update).attr('d', tipPath);
        geneTipMerged.transition().duration(duration).delay(delay.enter).attr('fill', function (n) {
          return n.id == 'NA' ? color.noData : palette.get(n.id);
        }).style('opacity', 1);
        geneTip.exit().transition().duration(duration).style('opacity', 0).remove();
        geneG.select('path.light-stroke').transition().duration(duration).delay(delay.update).attr('d', strokePath);
        geneG.select('path.stroke').attr('d', strokePath).attr('class', 'stroke ' + unfNots.filter(filterByLevel).map(function (n) {
          return "c".concat((0, _helpers.cleanString)(n.id));
        }).join(' ')).transition().duration(duration).delay(delay.update).style('opacity', 0);
        geneG.select('text.geneName').attr('y', geneRect.h / 1.7).transition().duration(duration).delay(delay.update).attr('x', geneWidth / 2 - geneRect.ph / 2 + (d.strand == '-' ? tipWidth : 0)).style('opacity', function (g) {
          return options.showName && getShowName(g) != "." ? 1 : 0;
        }).text(function (g) {
          return getShowName(g);
        });
      }

      enterGenes = function enterGenes() {
        var genes = contextG.selectAll('g.gene').data(data, function (d) {
          return d.anchor + d.pos;
        });
        genes.transition().duration(duration).delay(delay.update).attr('transform', function (d) {
          return "translate(".concat(getX(d), ", ").concat(getY(d), ")");
        });
        genes.transition().duration(duration).delay(delay.enter).style('opacity', 1);
        genes.enter().append('g').attr('class', function (d) {
          var cl = 'gene';
          cl += d.pos == 0 ? ' anchor' : '';
          return cl;
        }).attr('id', function (d) {
          return 'gene' + (0, _helpers.cleanString)(d.anchor + d.pos);
        }).attr('transform', function (d) {
          return "translate(".concat(getX(d), ", ").concat(getY(d), ")");
        }).style('opacity', 0).each(enterGene).transition().duration(duration).delay(delay.enter).style('opacity', 1);
        updateHeight();
        resizeSVG();
      };

      exitGenes = function exitGenes() {
        var genes = contextG.selectAll('g.gene').data(data, function (d) {
          return d.anchor + d.pos;
        });
        genes.transition().duration(duration).delay(delay.update).attr('transform', function (d) {
          return "translate(".concat(getX(d), ", ").concat(getY(d), ")");
        });
        genes.exit().transition().duration(duration).delay(delay.exit).style('opacity', 0).remove();
        updateHeight();
        resizeSVG();
      };

      updateGenes = function updateGenes() {
        // Update data-dependant variables
        var update = contextG.selectAll('g.gene').data(data, function (d) {
          return d.anchor + d.pos;
        });
        update.enter().append('g').attr('class', function (d) {
          var cl = 'gene';
          cl += d.pos == 0 ? ' anchor' : '';
          return cl;
        }).attr('id', function (d) {
          return 'gene' + (0, _helpers.cleanString)(d.anchor + d.pos);
        }).attr('transform', function (d) {
          return "translate(".concat(getX(d), ", ").concat(getY(d), ")");
        }).style('opacity', 0).each(enterGene).transition().duration(duration).delay(delay.enter).style('opacity', 1);
        update.merge(update).transition().duration(duration).delay(delay.update).attr('transform', function (d) {
          return "translate(".concat(getX(d), ", ").concat(getY(d), ")");
        }).style('opacity', 1).each(updateGene);
        update.exit().transition().duration(duration).delay(delay.exit).style('opacity', 0).remove();
        resizeSVG();
      };

      var container = (0, _d2.select)(this);
      var legendContainer, splitLegend, graphContainer, contextAndLegend, contextContainer, contextG;
      initChart(container);
      parameterListener();
      updateHeight();
    });
  }

  function buildDomain() {
    domain = data.map(function (d) {
      var not = d[notation];
      return !not ? [] : _typeof(not) == 'object' ? not.map(function (n) {
        return n.id;
      }) : [not];
    }).flat();
    domain = _toConsumableArray(new Set(domain));
  }

  function updatePalette() {
    var shuffle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    buildDomain();
    palette.buildPalette(domain);
    if (shuffle) palette.shuffle();
  }

  function filterAnchor(a) {
    return !excludedAnchors.includes(a) ? true : false;
  }

  function computeCoordinates() {
    function buildScale() {
      var sizeRange = (0, _d2.extent)(data.map(function (d) {
        var size = Math.abs(+d.end - +d.start);
        return size > 0 ? size : undefined;
      })); // TipWidth + a small rect is the minimum width

      var scaleRange = [tipWidth + 10, undefined];
      var initialScale = (0, _d2.scaleLinear)().domain([0, sizeRange[0]]).range([0, scaleRange[0]]);
      scaleRange[1] = initialScale(sizeRange[1]);

      var distScale = function distScale(d) {
        var scale = (0, _d2.scaleLinear)().domain(sizeRange).range(scaleRange);
        var sign = +d / Math.abs(+d);
        return +(sign * +scale(Math.abs(+d)));
      };

      var sizeScale = function sizeScale(s) {
        return distScale(s) - tipWidth + geneRect.ph;
      };

      return [distScale, sizeScale];
    }

    function getDist(d, neigh, swapped, pos) {
      var dist;
      if (!swapped) dist = pos > 0 ? +d.start - +neigh.end : +neigh.start - +d.end;else dist = pos > 0 ? +neigh.start - +d.end : +d.start - +neigh.end;
      return dist;
    }

    var _buildScale = buildScale(),
        _buildScale2 = _slicedToArray(_buildScale, 2),
        distScale = _buildScale2[0],
        sizeScale = _buildScale2[1]; // Data should be sorted to compute virtual start and end


    data = _sorter["default"].sort(data, function (a, b) {
      return Math.abs(parseInt(b.pos)) < Math.abs(parseInt(a.pos));
    });
    data.sort(function (a, b) {
      return b.anchor < a.anchor;
    });
    data.forEach(function (d) {
      var swapped = swappedAnchors.includes(d.anchor);

      if (+d.start && +d.end) {
        var anchoredData = data.filter(function (el) {
          return el.anchor == d.anchor;
        });
        d.size = +Math.abs(+d.end - +d.start);
        d.vSize = sizeScale(d.size);

        if (+d.pos == 0) {
          d.vStart = (width - 7) / 2;
          d.vEnd = +d.vStart + distScale(d.size);
        } else {
          if (+d.pos > 0) {
            var neigh = anchoredData.find(function (n) {
              return +n.pos == +d.pos - 1;
            });
            var dist = distScale(getDist(d, neigh, swapped, 1)) || 0;
            d.vStart = +neigh.vEnd + dist;
            d.vEnd = d.vStart + distScale(d.size);
          } else if (+d.pos < 0) {
            var _neigh = anchoredData.find(function (n) {
              return +n.pos == +d.pos + 1;
            });

            var _dist = distScale(getDist(d, _neigh, swapped, -1)) || 0;

            d.vEnd = +_neigh.vStart - _dist;
            d.vStart = d.vEnd - distScale(d.size);
          }
        }
      } else {
        d.vSize = geneRect.w;
        d.vStart = undefined;
        d.vEnd = undefined;
      }
    });
    console.log(data);
  }

  function updateData() {
    data = unfData.filter(function (d) {
      return Math.abs(+d.pos) <= nSide && filterAnchor(d.anchor);
    });
    anchors = data.filter(function (d) {
      return d.pos == 0;
    });
    if (options.scaleDist) computeCoordinates();
  }

  function swapStrands(unswapped) {
    swappedAnchors = unswapped.map(function (d) {
      if (d.pos == 0 && d.strand == '-') return d.anchor;
    });
    var swapped = [];
    unswapped.forEach(function (d) {
      var dCopy = Object.assign({}, d);

      if (swappedAnchors.includes(d.anchor)) {
        dCopy.pos = -1 * +d.pos;
        dCopy.strand = d.strand == '+' ? '-' : '+';
      }

      swapped.push(dCopy);
    });
    return swapped;
  }

  chart.data = function (d) {
    if (!arguments.length) return data;
    unfData = swapStrands(d);
    if (typeof updateData === 'function') updateData();
    if (typeof updatePalette === 'function') updatePalette();
    if (typeof updateGenes === 'function') updateGenes();
    return chart;
  };

  chart.tree = function (n) {
    var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['name'];
    if (!arguments.length) return newick;
    if (n) newick = (0, _newick["default"])(n, fields);
    newickFields = fields;
    return chart;
  };

  chart.heatmap = function () {};

  chart.toggleTree = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var toggle,
        phylogramContainer,
        phylogramSVG,
        targetWidth,
        _args = arguments;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            toggle = _args.length > 0 && _args[0] !== undefined ? _args[0] : true;
            phylogramContainer = (0, _d2.select)(selector).select('.phylogramContainer');
            phylogramSVG = phylogramContainer.select('svg');

            if (newick && toggle) {
              if (!phylogramSVG.node()) {
                (0, _tree["default"])(selector + ' .phylogramContainer', newick, newickFields, {
                  enterEach: treeLeafEnter,
                  enterMouseOver: treeLeafMouseOver,
                  enterMouseLeave: treeLeafMouseLeave,
                  enterClick: treeLeafClick,
                  exitEach: treeLeafExit
                });
              }

              targetWidth = phylogramContainer.select('svg').attr('target-width');
              phylogramContainer.transition().duration(duration).delay(delay.update).style('width', "".concat(targetWidth, "px"));
              phylogramContainer.transition().duration(duration).delay(delay.enter).style('opacity', 1);
            } else {
              phylogramContainer.style('opacity', 0).style('width', 0);
            }

            chart.nSide(nSide);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  chart.toggleLegend = function () {
    var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var legendContainer = (0, _d2.select)(selector).select('.legendContainer');
    var splitLegend = legendContainer.select('.split-legend');

    if (toggle) {
      legendContainer.style('width', '320px');
      splitLegend.style('width', '300px');
      legendContainer.transition().duration(duration).delay(delay.enter).style('opacity', 1);
    } else {
      legendContainer.style('opacity', 0).style('width', 0);
      splitLegend.style('width', 0);
    }

    chart.nSide(nSide);
  };

  chart.scaleDist = function () {
    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    options.scaleDist = scale;
    chart.nSide(nSide);
  };

  chart.nSide = function (d) {
    if (!arguments.length) return nSide;
    nSide = d;
    if (typeof updateWidth === 'function') updateWidth();
    if (typeof updateData === 'function') updateData();
    if (typeof updateLegend === 'function') updateLegend();
    if (typeof updateGenes === 'function') updateGenes();
    return chart;
  };

  chart.notation = function (not) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    if (!arguments.length) return notation;
    notation = not;
    notationLevel = level;
    if (typeof updatePalette === 'function') updatePalette();
    if (typeof updateLegend === 'function') updateLegend();
    if (typeof updateNotation == 'function') updateNotation();
    return chart;
  };

  chart.excludeNotation = function (notationID) {
    var exclude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (!arguments.length) return excludedNotation;

    if (exclude && !excludedNotation.includes(notationID)) {
      excludedNotation.push(notationID);
    } else if (!exclude && excludedNotation.includes(notationID)) {
      excludedNotation = excludedNotation.filter(function (n) {
        return n != notationID;
      });
    }

    if (typeof updateNotation == 'function') updateNotation();
    return chart;
  };

  chart.excludeAnchor = function (anchor) {
    var exclude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (!arguments.length) return excludedAnchors;

    if (exclude && !excludedAnchors.includes(anchor)) {
      excludedAnchors.push(anchor);
      if (typeof updateData == 'function') updateData();
      if (typeof exitGenes == 'function') exitGenes();
    } else if (!exclude && excludedAnchors.includes(anchor)) {
      excludedAnchors = excludedAnchors.filter(function (a) {
        return a != anchor;
      });
      if (typeof updateData == 'function') updateData();
      if (typeof enterGenes == 'function') enterGenes();
    }

    return chart;
  };

  chart.showName = function (field) {
    if (!arguments.length) return showName;
    showName = field;
    if (typeof updateShowName == 'function') updateShowName();
    return chart;
  };

  chart.shuffleColors = function () {
    if (typeof updatePalette === 'function') updatePalette(true);
    if (typeof updateLegend === 'function') updateLegend();
    if (typeof updateNotation == 'function') updateNotation();
  };

  chart.toPng = function () {
    var toDownload = document.querySelector(selector + ' .graph-container');
    var dimensions = toDownload.getBoundingClientRect();
    var legendHeight = (0, _d2.select)(selector).select('.split-legend').node().getBoundingClientRect().height + 7;
    var scrollX = (0, _jquery["default"])(document).scrollLeft();
    var scrollY = (0, _jquery["default"])(document).scrollTop(); //['.phylogram',
    //'.gcontext',
    //'.split-legend'].forEach(d => {
    //select(selector)
    //.select(d)
    //.style('border-color', 'transparent');
    //})

    var splitLegend = (0, _d2.select)(selector).select('.split-legend');
    var legendEntries = splitLegend.selectAll('.lgnd-entry');
    splitLegend.select('.pl-3').style('display', 'none');
    legendEntries.select('label').style('padding-left', '.5rem');
    legendEntries.select('input').style('display', 'none');
    (0, _html2canvas["default"])(toDownload, {
      width: dimensions.width,
      height: Math.max(dimensions.height, legendHeight),
      scrollX: -scrollX,
      scrollY: -scrollY
    }).then(function (canvas) {
      canvas.toBlob(function (blob) {
        return (0, _fileSaver.saveAs)(blob, 'GeCoViz.png');
      });
      splitLegend.select('.pl-3').style('display', 'block');
      legendEntries.select('label').style('padding-left', '1.5rem');
      legendEntries.select('input').style('display', 'block'); //['.phylogram',
      //'.gcontext',
      //'.split-legend'].forEach(d => {
      //select(selector)
      //.select(d)
      //.style('border-color', 'var(--dark-gray)');
      //})
    });
  };

  (0, _popper.PopperClick)(selector + ' .gcontext');
  return chart;
};

var _default = GeCoViz;
exports["default"] = _default;